Binary codecs

> class HasCodec a where
>   codec :: Codec a


Primitives:

> instance HasCodec Char
>   codec = charCodec

Combinators:

> instance HasCodec a => HasCodec [a] where
>   codec = listCodec codec
> instance (HasCodec a, HasCodec b) => HasCodec (a, b) where
>   codec = pairCodec codec codec

Derived:

> stringCodec :: Codec String
> stringCodec = codec  -- listCodec charCodec

> alistCodec :: (HasCodec k, HasCodec v) => Codec [(k, v)]
> alistCodec = codec   -- listCodec (pairCodec codec codec)














































































































                   Combinator libraries

          Benefits                      Costs

        * Shorter                     * Need some up-front design to find
          (work hidden in combinators)  the proper primitives and combinators
        * More self-documenting
          (intermediate names)
        * Fewer mistakes
          (each system is consistent)








































































































